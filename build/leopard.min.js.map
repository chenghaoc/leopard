{"version":3,"sources":["leopard.js","control.js","schedule.js","rAF.js","emitter.js","index.js"],"names":["run","count","i","queue","length","level","counter","callback","shift","emitter","emit","enqueue","priority","times","push","frame","frameStart","isRunning","styleEnd","styleDuration","styleStart","goal","scriptDuration","scriptEnd","scriptStart","now","accelerate","limit","Math","floor","stop","requestAnimationFrame","window","requestIdleCallback","deadline","timeRemaining","ratio","perFrame","performance","Date","start","put","_typeof","Symbol","iterator","obj","constructor","lastTime","vendors","x","cancelAnimationFrame","element","currTime","getTime","timeToCall","max","id","setTimeout","clearTimeout","Emitter","this","uid","handlers","prototype","on","action","_len","arguments","args","Array","_key","forEach","handler","apply","once","_this","undefined","find","splice","indexOf","singletonEmitter","levels","balance","Leopard","bind","exports","module","define","amd"],"mappings":"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","file":"leopard.min.js","sourcesContent":["'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\n// http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating\n\n// requestAnimationFrame polyfill by Erik Möller. fixes from Paul Irish and Tino Zijdel\n\n// MIT license\n\n(function () {\n  var lastTime = 0;\n  var vendors = ['ms', 'moz', 'webkit', 'o'];\n  for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n    window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];\n    window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];\n  }\n\n  if (!window.requestAnimationFrame) window.requestAnimationFrame = function (callback, element) {\n    var currTime = new Date().getTime();\n    var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n    var id = window.setTimeout(function () {\n      callback(currTime + timeToCall);\n    }, timeToCall);\n    lastTime = currTime + timeToCall;\n    return id;\n  };\n\n  if (!window.cancelAnimationFrame) window.cancelAnimationFrame = function (id) {\n    clearTimeout(id);\n  };\n})();\n\nvar Emitter = function Emitter() {\n  this.uid = 0;\n  this.handlers = [];\n  // FIX 1000\n  for (var i = 0; i < 1000; i++) {\n    this.handlers.push([]);\n  }\n};\nEmitter.prototype.on = function (level, callback) {\n  this.handlers[level].push({\n    id: this.uid++,\n    action: callback\n  });\n};\nEmitter.prototype.emit = function (level) {\n  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  this.handlers[level].forEach(function (handler) {\n    if (typeof handler.action === 'function') handler.action.apply(handler, args);\n  });\n};\nEmitter.prototype.once = function (level, callback) {\n  var _this = this;\n\n  var id = this.uid;\n  this.on(level, function () {\n    callback.apply(undefined, arguments);\n    var handler = _this.handlers[level].find(function (handler) {\n      return handler.id === id;\n    });\n    _this.handlers[level].splice(_this.handlers[level].indexOf(handler), 1);\n    // delete handler\n  });\n};\nvar singletonEmitter = new Emitter();\n\nvar queue = [];\nvar counter = 0;\nvar levels = 1000;\n\nfor (var i = 0; i < levels; i++) {\n  queue.push([]);\n}function run(count) {\n  for (var i = 0; i < queue.length; i++) {\n    if (count < 1) break;\n    var level = queue[i];\n    while (level.length) {\n      if (count < 1) break;\n      counter--;\n      // the bigger of level, the less emergent to complete\n      // So we deduce more for higher level (lower priority) actions\n      count = count - i * i;\n      var callback = level.shift();\n      if (callback && typeof callback === 'function') callback();\n      if (!level.length) {\n        singletonEmitter.emit(i);\n      }\n    }\n    if (i === queue.length - 1 && counter === 0) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction enqueue(priority, callback, times) {\n  if (!times) {\n    queue[priority].push(callback);\n    counter++;\n  } else {\n    while (times--) {\n      queue[priority].push(callback);\n      counter++;\n    }\n  }\n}\n\nvar perFrame = 16;\nvar limit = 10;\nvar balance = limit;\nvar goal = perFrame;\nvar isRunning = false;\nvar accelerate = 1; // for slow start\n\nvar scriptStart;\nvar scriptEnd;\nvar styleStart;\nvar styleEnd;\n\nvar styleDuration;\nvar scriptDuration;\n\nfunction frame(frameStart) {\n  if (!isRunning) return;\n\n  // calculate metrix\n  styleEnd = frameStart;\n  styleDuration = styleStart ? styleEnd - styleStart : goal;\n  scriptDuration = scriptEnd - scriptStart;\n  scriptStart = now();\n  // console.log(limit)\n  // console.log(styleDuration);\n\n  // calculate limit\n  if (goal <= styleDuration && styleDuration < goal + 1 && styleDuration !== 0) {\n    accelerate = accelerate * 2;\n    limit += accelerate;\n  } else if (styleDuration >= goal + 1) {\n    accelerate = 1;\n    limit = Math.floor(limit / 2);\n  } else if (styleDuration === 0) {\n    // This is a skipped frame\n  }\n  if (limit < 1) limit = 1;\n  if (!run(limit)) // stop {\n    stop();\n  scriptEnd = now();\n  styleStart = frameStart;\n\n  requestAnimationFrame(frame);\n  if (window && window.requestIdleCallback) {\n    // For browsers which support requestIdleCallback\n    requestIdleCallback(function (deadline) {\n      if (deadline.timeRemaining() > 0) {\n        var ratio = deadline.timeRemaining() / perFrame;\n        run(Math.floor(limit * ratio));\n      }\n    });\n  }\n}\n\nfunction now() {\n  return performance.now() || Date.now();\n}\n\nfunction stop() {\n  accelerate = 1; // for slow start\n  isRunning = false;\n}\nfunction start() {\n  scriptStart = null;\n  scriptEnd = null;\n  styleStart = null;\n  styleEnd = null;\n  isRunning = true;\n  requestAnimationFrame(frame);\n}\nfunction put(priority, callback, times) {\n  enqueue(priority, callback, times);\n  if (!isRunning) start();\n}\n\nvar Leopard = {\n  on: singletonEmitter.on.bind(singletonEmitter),\n  once: singletonEmitter.once.bind(singletonEmitter),\n  start: start,\n  stop: stop,\n  put: put\n};\n\nif ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') module.exports = Leopard;else if (typeof define === 'function' && typeof define.amd !== 'undefined') define(function () {\n  return Leopard;\n});else window.Leopard = Leopard;","import emitter from './emitter'\nvar queue = []\nvar counter = 0\nvar levels = 1000\n\nfor (let i = 0; i < levels; i ++) queue.push([])\n\nexport function run(count) {\n  for (var i = 0; i < queue.length; i ++) {\n    if (count < 1) break\n    var level = queue[i]\n    while (level.length) {\n      if (count < 1) break\n      counter --\n      // the bigger of level, the less emergent to complete\n      // So we deduce more for higher level (lower priority) actions\n      count = count - i * i\n      var callback = level.shift()\n      if (callback && typeof callback === 'function') callback()\n      if (!level.length) {\n        emitter.emit(i)\n      }\n    }\n    if (i === queue.length - 1 && counter === 0) {\n      return false\n    }\n  }\n  return true\n}\nexport function enqueue(priority, callback, times) {\n  if (!times) {\n    queue[priority].push(callback)\n    counter ++\n  } else {\n    while (times--)  {\n      queue[priority].push(callback)\n      counter ++\n    }\n  }\n  \n}\n","import { run, enqueue } from './control'\nvar perFrame = 16\nvar limit = 10\nvar balance = limit\nvar goal = perFrame\nvar isRunning = false\nvar accelerate = 1 // for slow start\n\nvar scriptStart\nvar scriptEnd\nvar styleStart\nvar styleEnd\n\nvar styleDuration\nvar scriptDuration\n\n\nfunction frame(frameStart) {\n  if (!isRunning) return\n\n  // calculate metrix\n  styleEnd = frameStart\n  styleDuration = styleStart ? (styleEnd - styleStart) : goal\n  scriptDuration = scriptEnd - scriptStart\n  scriptStart = now()\n  // console.log(limit)\n  // console.log(styleDuration);\n\n  // calculate limit\n  if (goal <= styleDuration && styleDuration < goal + 1 &&\n      styleDuration !== 0) {\n    accelerate = accelerate * 2\n    limit += accelerate\n  } else if (styleDuration >= goal + 1) {\n    accelerate = 1\n    limit = Math.floor(limit / 2)\n  } else if (styleDuration === 0) {\n    // This is a skipped frame\n  }\n  if (limit < 1)\n    limit = 1\n  if (!run(limit)) // stop {\n    stop()\n  scriptEnd = now()\n  styleStart = frameStart\n  \n  requestAnimationFrame(frame)\n  if (window && window.requestIdleCallback) {\n    // For browsers which support requestIdleCallback\n    requestIdleCallback(function(deadline) {\n      if (deadline.timeRemaining() > 0) {\n        var ratio = deadline.timeRemaining() / perFrame\n        run(Math.floor(limit * ratio))\n      }\n    })\n  }\n}\n\n\nfunction now() {\n  return performance.now() || Date.now()\n}\n\nexport function stop() {\n  accelerate = 1 // for slow start\n  isRunning = false\n}\nexport function start() {\n  scriptStart = null\n  scriptEnd = null\n  styleStart = null\n  styleEnd = null\n  isRunning = true\n  requestAnimationFrame(frame)\n\n}\nexport function put(priority, callback, times) {\n  enqueue(priority, callback, times)\n  if (!isRunning)\n    start()\n}\n","// http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating\n\n// requestAnimationFrame polyfill by Erik Möller. fixes from Paul Irish and Tino Zijdel\n\n// MIT license\n\n(function() {\n  var lastTime = 0\n  var vendors = ['ms', 'moz', 'webkit', 'o']\n  for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n    window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame']\n    window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] ||\n                                   window[vendors[x] + 'CancelRequestAnimationFrame']\n  }\n\n  if (!window.requestAnimationFrame)\n        window.requestAnimationFrame = function(callback, element) {\n          var currTime = new Date().getTime()\n          var timeToCall = Math.max(0, 16 - (currTime - lastTime))\n          var id = window.setTimeout(function() { callback(currTime + timeToCall); },\n              timeToCall)\n          lastTime = currTime + timeToCall\n          return id\n        }\n\n  if (!window.cancelAnimationFrame)\n        window.cancelAnimationFrame = function(id) {\n          clearTimeout(id)\n        }\n}())\n","var Emitter = function() {\n  this.uid = 0\n  this.handlers = []\n  // FIX 1000\n  for (let i = 0; i < 1000; i ++) this.handlers.push([])\n}\nEmitter.prototype.on = function(level, callback) {\n  this.handlers[level].push({\n    id: this.uid ++,\n    action: callback\n  })\n}\nEmitter.prototype.emit = function(level, ...args) {\n  this.handlers[level].forEach(handler => {\n    if (typeof(handler.action) === 'function')\n      handler.action(...args)\n  })\n}\nEmitter.prototype.once = function(level, callback) {\n  var id = this.uid\n  this.on(level, (...args) => {\n    callback(...args)\n    var handler = this.handlers[level].find(handler => handler.id === id)\n    this.handlers[level].splice(this.handlers[level].indexOf(handler), 1)\n    // delete handler\n  })\n}\nvar singletonEmitter = new Emitter()\nexport default singletonEmitter\n","import _ from './rAF'\nimport {\n  start,\n  stop,\n  put\n} from './schedule'\nimport emitter from './emitter'\nvar Leopard = {\n  on: emitter.on.bind(emitter),\n  once: emitter.once.bind(emitter),\n  start,\n  stop,\n  put\n}\n\nif (typeof exports === 'object')\n    module.exports = Leopard\nelse if (typeof define === 'function' && typeof define.amd !== 'undefined')\n  define(function() { return Leopard })\nelse\n  window.Leopard = Leopard\n"],"sourceRoot":"/source/"}